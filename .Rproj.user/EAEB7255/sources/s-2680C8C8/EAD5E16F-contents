## Understory electivity
library(plyr)
library(vioplot)
library(reshape2)
library(multcompView)

set.seed(16091315)

daub <- read.csv("./raw data/daub_cover.csv", stringsAsFactors = FALSE)

#some data proofing
  daub <- daub[(daub$Transect %in% c("N", "E", "S", "W")), ]
  daub$Plot <- as.character(daub$Plot)
  daub[daub$Plot == "NPElectricEel", "Plot"] <- "NPELECTRICEEL"
  daub[daub$Plot == "NPElectricEel120", "Plot"] <- "NPELECTRICEEL120"
  daub[daub$Plot == "NPElectricEel240", "Plot"] <- "NPELECTRICEEL240"
  daub[daub$Plot == "NPElectricEel360", "Plot"] <- "NPELECTRICEEL360"
daub$Midpoint.value <- as.numeric(as.character((daub$Midpoint.value)))
daub$unique_quad <- paste0(daub$Plot, daub$Transect, daub$Meter) 
daub[daub$Cover.type == "Perennial forb ", "Cover.type"] <- "Perennial forb"
daub[daub$Cover.type == "Shrub ", "Cover.type"] <- "Shrub"

species<- read.csv("./raw data/spp_cover2.csv")
species <- species[(species$Transect %in% c("N", "E", "S", "W")), ]
species$unique_quad <- paste0(species$Plot, species$Transect, species$Meter)

count(species, vars = c("Plot", "Transect"))

types <- c("Perennial grass", "Cheatgrass", "Perennial forb", "Shrub")

#-----------------------------------------------------------------------
# Calculate mean cover, cover by quadrat, cover by plot
#-------------------------------------------------------------------
# Mean overall cover
length(unique(daub$unique_quad))
spp_abund <- aggregate(species$Cover / 2040, by = list(species$Species), FUN = sum)
spp_abund <- spp_abund[order(spp_abund[, 1], decreasing = FALSE), ]



#percent of quadrats occupied
quadrat_abund <- as.data.frame(table(species[species$Cover != 0, ]$Species))
quadrat_abund <- quadrat_abund[order(quadrat_abund[, 1], decreasing = FALSE), ]
quadrat_abund[, 2] <- quadrat_abund[, 2] * 100 / 2040


count <- table(species$Species, species$Plot)
is.not.zero <- function(x){
  if((x) == 0){return(0)}
  else{return(1)}
}

presence <- apply(count, c(1,2), FUN = is.not.zero)
plot_presence <- as.data.frame(rowSums(presence))/102*100

spp_abund <- cbind(spp_abund, quadrat_abund[-1, 2], plot_presence[-1, 1])

write.csv(spp_abund, "./outputs/species_summary.csv")


## generate cover data for different subsets
n_quads_occ <- length(unique(species$unique_quad)) #number of quadrat-by-group records

spp_cov <- data.frame(unique_quad = unique(species$unique_quad),
                     poasec = numeric(n_quads_occ),
                     othergrass = numeric(n_quads_occ),
                     phlhoo = numeric(n_quads_occ),
                     otherforb = numeric(n_quads_occ))


for(i in 1:n_quads_occ){
  spp_cov$poasec[i] <- ifelse(species[species$unique_quad == spp_cov$unique_quad[i], ]$Species == "POASEC",
    species[species$unique_quad == spp_cov$unique_quad[i] & species$Species == "POASEC", ]$Cover, 0)
  
  spp_cov$othergrass[i] <- ifelse(species[species$unique_quad == spp_cov$unique_quad[i], ]$Species %in% c("PSESPI", "LEYCIN", "ELYELY", "STITHU"),
                                   sum(species[species$unique_quad == spp_cov$unique_quad[i] 
                                               & species$Species %in% c("PSESPI", "LEYCIN", "ELYELY", "STITHU"), ]$Cover), 0)
  
  spp_cov$phlhoo[i] <- ifelse(species[species$unique_quad == spp_cov$unique_quad[i], ]$Species == "PHLHOO",
                              species[species$unique_quad == spp_cov$unique_quad[i] & species$Species == "PHLHOO", ]$Cover, 0)
  
  spp_cov$otherforb[i] <- ifelse(species[species$unique_quad == spp_cov$unique_quad[i], ]$Species %in% c("CREACA", "CREACU", "STEACA", "ERICAE", "LEPPUN", "ERIUMB", "AREACU","LESKIN","GALAPA","ASTPUR","BALSAG","CRYFLA","ERIMIC","MINKIN","ASTOOP","OPUPOL","ARAHOL","ANTDIM","BOEHOL"),
                                  sum(species[species$unique_quad == spp_cov$unique_quad[i] 
                                              & species$Species %in% c("CREACA", "CREACU", "STEACA", "ERICAE", "LEPPUN", "ERIUMB", "AREACU","LESKIN","GALAPA","ASTPUR","BALSAG","CRYFLA","ERIMIC","MINKIN","ASTOOP","OPUPOL","ARAHOL","ANTDIM","BOEHOL"), ]$Cover), 0)
}
                     
#----------------------------------------------------------------------------
# import and recode microsite data
ms <- read.csv("./raw data/microsite.csv")
ms$Microsite <- toupper(ms$Microsite)
ms$ms <- ifelse(ms$Microsite %in% c("PI",  "JI",  "CI", "PO", "JO", "CO"), "Live",
                # ifelse(ms$Microsite %in% c("PO", "JO", "CO"), "Live Outer", 
                ifelse(ms$Microsite %in% c("PI(S)", "PO(S)", "JI(S)", "JO(S)", "CI(S)", "CO(S)", "LOG"), "Dead",
                       # ifelse(ms$Microsite =="LOG", "Log",
                       ifelse(ms$Microsite == "I", "Inter", NA)))#))
ms[ms$Transect == "e", "Transect"] <- "E"
ms[ms$Transect == "s", "Transect"] <- "S"
ms[ms$Transect == "w", "Transect"] <- "W"
ms[ms$Transect == "n", "Transect"] <- "N"

ms$Plot <- as.character(ms$Plot)

ms <- ms[(ms$Transect %in% c("N", "S", "E", "W")), ]

ms[ms$Plot == "NPElectricEel120", "Plot"] <- "NPELECTRICEEL120"


ms$unique_quad <- paste0(ms$Plot, ms$Transect, ms$Meter)

#get total cover for each plot
total_cover <- aggregate(daub$Midpoint.value, by = list(daub$Plot, daub$Cover.type), FUN = sum)

## select which plots have enough microsites of each type
# this is a real friggin mess but it pulls out the plots which have 
# at least n_plots dead and at least n_plots live ms,
# and a minimum plot cover for the type of mincov
plots_to_use_dead <- NA
plots_to_use_live <- NA
n_plots <- 1
mincov <- 0

for(i in 1:length(unique(ms$Plot))){
   table <- table(ms[ms$Plot == unique(ms$Plot)[i], ]$ms)
  
  if("Dead" %in% names(table)){
    plots_to_use_dead[i] <- table["Dead"]
    } else{
      plots_to_use_dead[i] <- 0
    }
  
  if("Live" %in% names(table)){
    plots_to_use_live[i] <- table["Live"]
    } else{
      plots_to_use_live[i] <- 0
    }
}

plots_to_use_dead <- (plots_to_use_dead >= n_plots)
plots_to_use_live <- (plots_to_use_live >= n_plots)

plots_to_use <- unique(ms$Plot)[plots_to_use_dead & plots_to_use_live]

plots_to_use_all_types <- vector("list", length = 4)
names(plots_to_use_all_types) <- types

for(type in types){
  
  total_cover_type <- total_cover[total_cover$Group.2 == type, ]
  plots_enough_cover <- total_cover_type[total_cover_type$x > mincov, "Group.1"]
  
  plots_to_use_all_types[[type]] <- subset(plots_to_use, plots_to_use %in% plots_enough_cover)
}

#------------------------------------------------------------------------------
# Calculate test and randomized distributions
#------------------------------------------------------------------------------
#perform analysis for the four FTs
types <- c("Perennial grass", "Cheatgrass", "Perennial forb", "Shrub")

#initialize a list of dataframes to catch the electivities at each plot/FT
elect_results <- list()
for(i in 1:4){
  elect_results[[i]] <- data.frame(Plot = numeric(0),
                                 Dead = numeric(0),
                                 Live = numeric(0),
                                 Inter = numeric(0))
}
names(elect_results) <- types


for(type in types){
  
  plots_to_use <- plots_to_use_all_types[[type]]
  
  for (i in 1:length(plots_to_use)){
    
    daub_cov <- daub[daub$Cover.type == type & daub$Plot == as.character(plots_to_use[i]), ]
    daub_cov <- join(daub_cov, ms[, c("unique_quad", "ms")], by = "unique_quad", type = "inner")
    
    daub_cov$prop_cov <- daub_cov$Midpoint.value / sum(daub_cov$Midpoint.value)
    
    cov <- aggregate(daub_cov[, "prop_cov"], by = list(daub_cov$ms), FUN = sum)
    prev <- table(daub_cov$ms)/20
    
    elect <- data.frame(Plot = daub_cov$Plot[1],
                        Dead = (cov[cov$Group.1 == "Dead",2] - prev[which(names(prev) == "Dead")]) / 
                          (cov[cov$Group.1 == "Dead", 2] + prev[which(names(prev) == "Dead")]),
                        Live = (cov[cov$Group.1 == "Live",2] - prev[which(names(prev) == "Live")]) / 
                          (cov[cov$Group.1 == "Live",2] + prev[which(names(prev) == "Live")]),
                        Inter = (cov[cov$Group.1 == "Inter",2] - prev[which(names(prev) == "Inter")]) / 
                          (cov[cov$Group.1 == "Inter",2] + prev[which(names(prev) == "Inter")]))
    
    elect_results[[type]] <- rbind(elect_results[[type]], elect)
  }
}

saveRDS(elect_results, paste0("./outputs/results_elect_", n_plots, "dead.rds"))

elect_results <- readRDS("./outputs/results_elect_1dead.rds")
#------------------------------------------------------------------------------
#Calculate randomized mean
#------------------------------------------------------------------------------
nit <- 999 #number of boostraps

#initialize a list of dataframes to catch the electivities at each plot/FT
elect_means <- list()
for(i in 1:4){
  elect_means[[i]] <- data.frame(Iter = numeric(0),
                                 Dead = numeric(0),
                                 Live = numeric(0),
                                 Inter = numeric(0))
}
names(elect_means) <- types

system.time(#takes about a half hour

for(type in types){

  plots_to_use <- plot_to_use_all_types[[type]]
  
  for(j in 1:nit){
    
    elect_rand <- data.frame(Plot = character(0),
                             Dead = numeric(0),
                             Live = numeric(0),
                             Inter = numeric(0))
  
    for (plot_use in plots_to_use){
      
      daub_cov <- daub[daub$Cover.type == type & daub$Plot == as.character(plot_use), ]
      daub_cov <- join(daub_cov, ms[, c("unique_quad", "ms")], by = "unique_quad", type = "inner")
      
      daub_cov$prop_cov <- daub_cov$Midpoint.value / sum(daub_cov$Midpoint.value)
      daub_cov$prop_cov_ran <- sample(daub_cov$prop_cov, size = 20, replace = FALSE)
      
      cov <- aggregate(daub_cov[, "prop_cov_ran"], by = list(daub_cov$ms), FUN = sum)
      prev <- table(daub_cov$ms)/20
      
      elect <- data.frame(Plot = plot_use,
                          Dead = (cov[cov$Group.1 == "Dead",2] - prev[which(names(prev) == "Dead")]) / 
                            (cov[cov$Group.1 == "Dead", 2] + prev[which(names(prev) == "Dead")]),
                          Live = (cov[cov$Group.1 == "Live",2] - prev[which(names(prev) == "Live")]) / 
                            (cov[cov$Group.1 == "Live",2] + prev[which(names(prev) == "Live")]),
                          Inter = (cov[cov$Group.1 == "Inter",2] - prev[which(names(prev) == "Inter")]) / 
                            (cov[cov$Group.1 == "Inter",2] + prev[which(names(prev) == "Inter")]))
      
      elect_rand <- rbind(elect_rand, elect)
    }
    
    means <- apply(elect_rand[, c(2:4)], 2, FUN = function(x){mean(x, na.rm = TRUE)})
    elect_means[[type]][j, 1] <- j
    elect_means[[type]][j, 2:4] <- means
    
  
  }
  
}
)


results_boots <- list()
for(i in 1:4){
  results_boots[[i]] <- data.frame(Dead = numeric(2),
                                 Live = numeric(2),
                                 Inter = numeric(2))
  rownames(results_boots[[i]]) <- c("Empirical", "N_boots_greater")
}
names(results_boots) <- types

#calculate p-values from distribution of bootstrapped mean electivities
for(i in 1:4){
emp_mean <- apply(elect_results[[i]][, 2:4], 2, FUN = function(x){mean(x, na.rm = TRUE)})

pvals <- c(sum(elect_means[[i]][2] > emp_mean[1]), 
           sum(elect_means[[i]][3] > emp_mean[2]), 
           sum(elect_means[[i]][4] > emp_mean[3]))

pvals <- ifelse(pvals > 500, (1000-pvals)/1000, pvals/1000)

results_boots[[i]][1, ] <- emp_mean
results_boots[[i]][2, ] <- pvals
}

saveRDS(results_boots, paste0("./outputs/results_boots_", n_plots, "dead.rds"))


results_boots <- readRDS("./outputs/results_boots_1dead.rds")
#-----------------------------------------------------------------------------------------------
# Plot of electivity for each FT
#-----------------------------------------------------------------------------------------------


par(mfrow = c(2,2),
    mar = c(2,1,2,2),
    oma = c(2,3,0,0))

for(i in 1:4){
# boxplot(elect_results[[i]][, 2:4], 
#         ylim = c(-1, 1))
  melt_elect <- melt(elect_results[[i]][, 2:4])
  plot(melt_elect$value ~ I(as.numeric(melt_elect$variable) + runif(nrow(melt_elect), -.1, .1 )),
       pch = 21,
       bg = "grey")
  pvals <- results_boots[[i]][2, ]
  abline(h = 0)
  text(x = c(1,2,3), y = 0.9, labels = pvals)
  mtext(text = types[i], outer = FALSE, side = 3, line = 0)
  mtext(text = paste0("(", letters[i], ")"), outer = FALSE, side = 3, at = 0.5, line = 0)
  mtext(text = "Electivity", outer = TRUE, side = 2, line = 1.5)
}



# #-----------------------------------------------------------------------------------------------
# # For whole study area
# #-----------------------------------------------------------------------------------------------
# all_merged <- join(daub, ms, by = "unique_quad", type = "inner")
# 
# daub$unique_quad
# ms$unique_quad
# 
# 
# all_plots_prev <- table(all_merged$ms)
# all_plots_prev <- all_plots_prev / sum(all_plots_prev)
# 
# all_plots_cover <- aggregate(all_merged$Midpoint.value, by = list(all_merged$Cover.type, all_merged$ms), FUN = sum)
# all_plots_cover <- all_plots_cover[all_plots_cover$Group.1 %in% c("Perennial grass", "Perennial forb ", "Shrub ", "Cheatgrass"), ]
# 
# for (i in 1:4){ # standardized cover so it adds to 1 for each functional type
#   types <- c("Cheatgrass", "Perennial forb ", "Perennial grass", "Shrub ")
#   all_plots_cover[all_plots_cover$Group.1 == types[i], "x"] <- all_plots_cover[all_plots_cover$Group.1 == types[i], "x"] / 
#     sum(all_plots_cover[all_plots_cover$Group.1 == types[i], "x"])
# }
# 
# 
# 
# all_plots_cover <- dcast(all_plots_cover, Group.1 ~ Group.2) #reshapes the table
# 
# all_elect <- data.frame(type = c("Cheatgrass", "Perennial forb", "Perennial grass", "Shrub"),
#                         Dead = numeric(4),
#                         Inter = numeric(4),
#                         LiveInner = numeric(4),
#                         LiveOuter = numeric(4),
#                         Log = numeric(4))
# 
# for (i in 2:6){ #calculate electivity
#   for (j in 1:4){
#     all_elect[j, i] <- (all_plots_cover[j,i] - all_plots_prev[i - 1]) / (all_plots_cover[j,i] + all_plots_prev[i - 1])
#   }
# }
# 
# 
# #--------------------------------------------------------------------
# 
# spp_merged <- join(spp_cov, ms, by = "unique_quad", type = "inner")
# head(spp_merged)
# 
# 
# spp_plots_prev <- table(spp_merged$ms)
# spp_plots_prev <- spp_plots_prev / sum(spp_plots_prev)
# 
# spp_merged$poasec <- spp_merged$poasec / sum(spp_merged$poasec)
# spp_merged$othergrass <- spp_merged$othergrass / sum(spp_merged$othergrass)
# spp_merged$phlhoo <- spp_merged$phlhoo / sum(spp_merged$phlhoo)
# spp_merged$otherforb <- spp_merged$otherforb / sum(spp_merged$otherforb)
# 
# spp_ag <- aggregate(spp_merged[, c("poasec", "othergrass", "phlhoo", "otherforb")], by = list(spp_merged$ms), FUN = sum)
# 
# 
# spp_elect <- data.frame(type = c("POASEC", "Other Perr Grass", "PHLHOO", "Other Forb"),
#                         Dead = numeric(4),
#                         Inter = numeric(4),
#                         LiveInner = numeric(4),
#                         LiveOuter = numeric(4),
#                         Log = numeric(4))
# 
# for (i in 1:5){ #calculate electivity
#   for (j in 1:4){
#     spp_elect[j, i+1] <- (unname(spp_ag[i,j + 1]) - unname(all_plots_prev[i])) / (unname(spp_ag[i,j + 1]) + unname(all_plots_prev[i]))
#   }
# }
# 
